матрица на вектор это вектор 

нужно найти лямбду собств числа и собств вектора. собств число - 3 макс по модулю 

генерируем по особ правилам  (матрицу?) - генерируем вектор сосбвт чисел - рандомный (aigen - собств) а потом сортируем по модулю


генерим рандомные вектора и нормируем 

нормировать - длинна == единица -- корень суммы квадратов 

омега - рандомно сгенерированный  и пронормированный 


Генериуем матрицу H - хоус холдера 
E - единица и омега и омегаТ - (омега и омегаТ - это перемножение двух вектором)

Далее зная матрицу H и собств значения лямбда - получаем A=H\*лямбда\*H(Tтрансп)

amid - промежуточная матрица,
дальше просто генерируем матрицу и А и матрицу H




мы уже знаем собственные значения и собственные вектора 


нам нужно составить алгоритма чтобы он считал максимально близко к оригиналу, не зная их 



1макс и 2макс мы уже знаем, получаем 3макс
высчитываем новую матрицу Хштрих - это изначальная матрица минус лямбда\*х[i]\*x[i]T



/// 
итеративный метод - 
взяли начальное x^(0) (икс нулевое)

генерируем начальное состояние
gen_orth вектор можно рандомными

далее считаем норму x^(0) (делим координаты на корень суммы квадратов)

эпсилон лямбда - разница между текущим и предыдущим собственнным значением

эпсилон джи - угол между текущим и предыдущим веткорами

считаем пока эти два значения не будут меньше эпсилона

avg_vec и avg_labmda - погрешность

далее считаем меру точности:
angle_vectors- высчитывание угла

dot_product - скалярное

dot_vec - вычисление нормы

мера r 
максимум ( Ax-лямбдаХ)

набор собственных значений - это набор лямбд 

точность задана 10-5 
если значение поставить 10-8 - он точность выведет ноль потому что там тригонометрия так работает. она арккосинус от маленького числа как 0 делает 

отчевт

постановку свою
методы решения: метод исчерпывания туда весь 

удалить гаусса
4 меняю на start)itearion - метод прямых 
внутри там написать 

